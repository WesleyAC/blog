<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Wesley Aptekar-Cassels | A simple but safe deploy script</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Regular-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Regular-Italic-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Bold-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/LatoLatin-Regular.woff2" as="font" type="font/woff2">

  <meta property="og:title" content="A simple but safe deploy script">
  <meta property="og:type" content="website">
  <meta property="og:url" content="/posts/simple-deploy-script">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="Wesley Aptekar-Cassels">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="/posts/simple-deploy-script">
  <meta name="twitter:title" content="A simple but safe deploy script">
  <meta name="twitter:description" content="">

  <link href="/feed.xml" type="application/rss+xml" rel="alternate" title="Wesley Aptekar-Cassels Last 10 blog posts" />

  <link type="text/css" rel="stylesheet" href="/light.css">
  <link type="text/css" rel="stylesheet" href="/dark.css">
</head>

<body>
  <main>
    <nav class="header-nav">
  <a href="/" class="header-logo" title="Wesley Aptekar-Cassels">Wesley Aptekar-Cassels</a>
  <div class="header-links">
    <a href="/feed.xml" target="_blank" title="RSS">
      <div style="width:16px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M56 336c31 0 56 25 56 56s-25 56-56 56-56-25-56-56 25-56 56-56zM0 192c140 0 256 116 256 256h-80c0-48-14-94-48-128S48 272 0 272v-80zM0 64c212 0 384 172 384 384h-80c0-171-133-304-304-304V64z"/></svg></div>
    </a>
    <a href="mailto:me@wesleyac.com" target="_blank" title="Email">
      <div style="width:18px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M422 407c-24 25-52 43-85 55s-69 18-105 18c-35 0-66-6-95-17s-53-26-73-46-36-43-47-71-17-58-17-90 6-62 18-89 29-51 50-71 46-35 74-47c28-11 58-17 90-17 28 0 55 4 81 12s49 20 69 36 36 36 48 60 18 53 18 85c0 24-3 46-10 64s-16 34-27 46-24 22-38 28-29 10-45 10-29-4-39-12-15-17-15-29h-3c-6 10-15 19-28 28s-28 13-46 13c-28 0-49-9-64-27s-23-42-23-71c0-17 3-34 9-50s14-31 24-44 23-23 38-31 31-12 49-12c15 0 27 4 38 10 10 6 18 15 21 24h1l5-24h54l-24 113c-1 6-2 12-3 19s-2 13-2 19c0 7 1 13 4 18s7 7 15 7c16 0 29-9 39-26s16-40 16-68c0-24-4-45-12-64s-20-34-34-47-32-23-52-29-41-9-65-9c-26 0-49 4-70 13s-39 22-54 38-27 34-35 56c-8 21-13 44-13 69 0 26 4 51 13 72s21 39 37 54 35 27 57 35 46 12 72 12c33 0 61-6 85-16s45-25 65-43zM231 188c-10 0-18 2-25 8s-14 13-19 22-8 18-11 28-4 20-4 30c0 5 0 10 1 16 1 5 3 10 6 15s7 8 12 11 11 5 19 5c11 0 20-3 28-8s14-13 19-21 9-16 11-26 3-19 3-27c0-6 0-13-1-19s-4-12-7-17-7-9-12-12-12-5-20-5z"/></svg></div>
    </a>
    <a href="https://github.com/WesleyAC" target="_blank" title="GitHub">
      <div style="width:18px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224 32c124 0 224 103 224 230 0 101-64 188-153 218h-4c-8 0-12-7-12-12 0-8 1-31 1-62 0-21-8-36-16-43 50-6 103-25 103-113 0-25-9-46-23-62 2-6 10-29-2-61h-5c-8 0-27 3-57 24-18-5-37-8-56-8s-38 3-56 8c-30-21-49-24-57-24h-5c-12 32-4 55-2 61-14 16-23 37-23 62 0 88 52 107 102 113-6 6-12 16-14 31-6 3-16 6-26 6-13 0-28-5-39-25 0 0-13-22-35-24-2 0-21 0-1 14 0 0 15 8 25 34 0 0 10 33 53 33 7 0 14 0 22-2v39c0 5-3 11-11 11h-4C64 450 0 364 0 262 0 135 100 32 224 32z"/></svg></div>
    </a>
  </div>
</nav>

    <article>
      <header class="article-header">
        <h1>A simple but safe deploy script</h1>
        <div class="article-list-date">
          Mar 1, 2021
        </div>
      </header>

      <div class="article-content">
        <p>I write a lot of small web servers as statically linked, single-file rust binaries, usually using <a href="https://github.com/emk/rust-musl-builder">rust-musl-builder</a> to generate the binary, and <a href="https://github.com/pyros2097/rust-embed/">rust-embed</a> to include the static files as part of the binary. This makes deploying really easy, but it still takes some care to get it really nice. What I want is a system where:</p>

<ul>
<li>I can run a single command to build and deploy my program</li>
<li>There will be minimal downtime</li>
<li>The server will always be running a valid version, even if my connection drops while the deploy script is running</li>
<li>Rollbacks are easy and fast</li>
</ul>

<p>It turns out it&#39;s pretty simple to write this! I&#39;m going to walk through it line-by-line, but you can see the entire script <a href="https://gist.github.com/WesleyAC/b3aaa0292579158ad566c140415c875d">here</a>, if you prefer to see it all at once.</p>

<p>We have a <code>deploy.sh</code> script, which will build and deploy our server:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/usr/bin/env bash</span>

<span class="nb">set</span> <span class="nt">-e</span>
<span class="nb">cd</span> <span class="si">$(</span><span class="nb">dirname</span> <span class="nv">$0</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"$#"</span> <span class="nt">-ne</span> 2 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"usage: </span><span class="nv">$0</span><span class="s2"> user@server-address /path/to/remote/directory/"</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>
</code></pre></div>
<p>We start with a <code>#!/usr/bin/env bash</code> to tell it to run in bash<sup id="fnref1"><a href="#fn1">1</a></sup>, <code>set -e</code> so it will quit if there are any errors, <code>cd $(dirname $0)</code> to make sure we&#39;re running in the directory we expect to be, and then finally an <code>if</code> statement to check that the script is being called correctly. Once we&#39;ve gotten that housekeeping out of the way, we carry on and set some variables that we&#39;ll use later:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">SERVER_SSH</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">SERVER_PATH</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">BINARY_NAME</span><span class="o">=</span><span class="s2">"example"</span>
<span class="nv">SERVER_RESTART_COMMAND</span><span class="o">=</span><span class="s2">"systemctl restart </span><span class="nv">$BINARY_NAME</span><span class="s2">"</span>
</code></pre></div>
<p>Once we&#39;ve set those, we go ahead and call our build script:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">./build.sh
</code></pre></div>
<p>Now that we have the binary, we need to figure out how to deploy it. We don&#39;t want to overwrite the existing binaries on the server, because then we won&#39;t be able to roll back properly, so we generate a unique name for this binary:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">OUTFILE</span><span class="o">=</span><span class="s2">"./target/x86_64-unknown-linux-musl/release/</span><span class="nv">$BINARY_NAME</span><span class="s2">"</span>
<span class="nv">COMMIT_HASH</span><span class="o">=</span><span class="si">$(</span>git rev-parse HEAD<span class="si">)</span>
<span class="nv">BUILD_TIMESTAMP</span><span class="o">=</span><span class="si">$(</span><span class="nv">TZ</span><span class="o">=</span>UTC <span class="nb">date</span> <span class="nt">-u</span> +<span class="s2">"%s"</span><span class="si">)</span>
<span class="nv">FILE_HASH</span><span class="o">=</span><span class="si">$(</span><span class="nb">b2sum</span> <span class="nv">$OUTFILE</span> | <span class="nb">cut</span> <span class="nt">-f1</span> <span class="nt">-d</span><span class="s1">' '</span><span class="si">)</span>
<span class="nv">REMOTE_FILENAME</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BINARY_NAME</span><span class="s2">-</span><span class="nv">$BUILD_TIMESTAMP</span><span class="s2">-</span><span class="nv">$COMMIT_HASH</span><span class="s2">-</span><span class="nv">$FILE_HASH</span><span class="s2">"</span>
</code></pre></div>
<p>This takes the current date in UTC, the commit hash, and a hash of the file, and appends them all to the name of the binary. This is a bit overkill, but it&#39;s nice to have all of that info readily available, so we can see what version is running and when it was deployed just from the filename. Now that we have our file, we can use <code>scp</code> to transfer it over to the server:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nv">$SERVER_SSH</span> <span class="s2">"mkdir -p </span><span class="nv">$SERVER_PATH</span><span class="s2">/versions/"</span>
scp <span class="s2">"</span><span class="nv">$OUTFILE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$SERVER_SSH</span><span class="s2">:</span><span class="nv">$SERVER_PATH</span><span class="s2">/versions/</span><span class="nv">$REMOTE_FILENAME</span><span class="s2">"</span>
</code></pre></div>
<p>At this point, everything we&#39;ve done has been safe from the perspective of our network dropping out — if anything fails in this process, all we&#39;ve done is transfered part of a file to the server, but that won&#39;t do anything bad. When we switch to the new version of the binary, though, we need to be a bit more careful. The most important part of the system that I use is that we never execute a binary directly, we always execute a <a href="https://en.wikipedia.org/wiki/Symbolic_link">soft link</a> to the binary. This means that when we remove the link, the existing server will keep running, since the actual binary that got executed is still the same. Here&#39;s how we go about that:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nt">-q</span> <span class="nt">-T</span> <span class="nv">$SERVER_SSH</span> <span class="o">&lt;&lt;</span><span class="no">EOL</span><span class="sh">
    nohup sh -c "</span><span class="se">\</span><span class="sh">
    rm "</span><span class="nv">$SERVER_PATH</span><span class="sh">/</span><span class="nv">$BINARY_NAME</span><span class="sh">" &amp;&amp; </span><span class="se">\</span><span class="sh">
    ln -s "</span><span class="nv">$SERVER_PATH</span><span class="sh">/versions/</span><span class="nv">$REMOTE_FILENAME</span><span class="sh">" "</span><span class="nv">$SERVER_PATH</span><span class="sh">/</span><span class="nv">$BINARY_NAME</span><span class="sh">" &amp;&amp; </span><span class="se">\</span><span class="sh">
    </span><span class="nv">$SERVER_RESTART_COMMAND</span><span class="sh">"
</span><span class="no">EOL
</span></code></pre></div>
<p>This runs a command on the server using <code>nohup</code>, which will ensure the command keeps running even if we disconnect. We use <code>sh -c</code> so that all of the commands are being run in the same <code>nohup</code> session. Then we remove the existing link, make a link to our new version, and restart the server. The only downtime we&#39;ll have is the time it takes for the server to start up, which is negligible for my rust binary. This will also kill existing sessions, but most of the applications I write are written in a way that is fairly robust to server restarts.</p>

<p>I ensured that this command actually does what I think it does by adding a <code>sleep 60</code> between the <code>rm</code> and <code>ln</code> commands, and killing the deploy script during that sleep, and sure enough, 60 seconds later, the server was up.</p>

<p>The last bits you need to implement this are the systemd unit file:</p>
<div class="highlight"><pre><code class="language-" data-lang="">[Unit]
Description=Example server
After=network.target

[Service]
ExecStart=/home/example/example
User=example
Group=example

[Install]
WantedBy=multi-user.target
</code></pre></div>
<p>and the build script:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/usr/bin/env bash</span>

<span class="nb">cd</span> <span class="si">$(</span><span class="nb">dirname</span> <span class="nv">$0</span><span class="si">)</span>

docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/home/rust/src <span class="nt">-v</span> cargo-git:/home/rust/.cargo/git <span class="nt">-v</span> cargo-registry:/home/rust/.cargo/registry <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">/target/"</span>:/home/rust/src/target ekidd/rust-musl-builder:nightly-2021-01-01 <span class="nb">sudo chown</span> <span class="nt">-R</span> rust:rust /home/rust/.cargo/git /home/rust/.cargo/registry /home/rust/src/target

docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/home/rust/src <span class="nt">-v</span> cargo-git:/home/rust/.cargo/git <span class="nt">-v</span> cargo-registry:/home/rust/.cargo/registry <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">/target/"</span>:/home/rust/src/target ekidd/rust-musl-builder:nightly-2021-01-01 cargo build <span class="nt">--release</span>
</code></pre></div>
<p>Although you can absolutely use this technique with any language/build system and init system, with only a little tweaking.</p>

<p>Doing a rollback is pretty simple — right now, I just ssh onto the server <code>rm</code> the old link, and <code>ln</code> the new version I want, but it would be easy to automate that. If I wanted to do that, I&#39;d probably have the deploy script write to a file every time it deployed a new version with the new filename, so that I could quickly roll back to the version N versions ago, or whatever<sup id="fnref2"><a href="#fn2">2</a></sup>. It&#39;s a little harder to scale this approach to do things like run multiple versions of the server at once to have a load balancer cut over connections slowly, without interrupting users, but for a lot of things you don&#39;t need to be that fancy, and this ~30 line script is more than enough.</p>

<p>I personally find that this approach hits the sweet spot of simple, understandable, and robust for a lot of my projects, and I hope you find it useful as well!</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Note that this is the most portable way to do this: some systems (most notably NixOS) don&#39;t have <code>/bin/bash</code> or <code>/usr/bin/bash</code>, but do have bash installed&nbsp;<a href="#fnref1">&#8617;</a></p>
</li>

<li id="fn2">
<p>You might think you can just <code>sort</code> the <code>versions/</code> directory to get this, but that doesn&#39;t actually work: if scp quits unexpectedly, there may be executables that don&#39;t even work in the <code>versions/</code> directory. We need to know which versions we actually got as far as making the link and starting up.&nbsp;<a href="#fnref2">&#8617;</a></p>
</li>

</ol>
</div>

      </div>

      <br>
      <!--
ooops, coronavirus happened, guess we're not doing this anymore :(
hopefully someday...
<p>If you're in NYC and want to meet up over lunch/coffee to chat about the future of technology, <a href="mailto:me@wesleyac.com">get in touch with me</a>.</p>
-->

      <br>
    </article>
  </main>
  <script async src="/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</body>
</html>
