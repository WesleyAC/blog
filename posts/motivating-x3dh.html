<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Wesley Aptekar-Cassels | Motivating X3DH</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Regular-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Regular-Italic-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/Harriet-v2-Text-Bold-latin1.woff2" as="font" type="font/woff2">
  <link rel="preload" href="/fonts/LatoLatin-Regular.woff2" as="font" type="font/woff2">

  <meta property="og:title" content="Motivating X3DH">
  <meta property="og:type" content="website">
  <meta property="og:url" content="/posts/motivating-x3dh">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="Wesley Aptekar-Cassels">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="/posts/motivating-x3dh">
  <meta name="twitter:title" content="Motivating X3DH">
  <meta name="twitter:description" content="">

  <link href="/feed.xml" type="application/rss+xml" rel="alternate" title="Wesley Aptekar-Cassels Last 10 blog posts" />

  <link type="text/css" rel="stylesheet" href="/light.css">
  <link type="text/css" rel="stylesheet" href="/dark.css">
</head>

<body>
  <main>
    <nav class="header-nav">
  <a href="/" class="header-logo" title="Wesley Aptekar-Cassels">Wesley Aptekar-Cassels</a>
  <div class="header-links">
    <a href="/feed.xml" target="_blank" title="RSS">
      <div style="width:16px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M56 336c31 0 56 25 56 56s-25 56-56 56-56-25-56-56 25-56 56-56zM0 192c140 0 256 116 256 256h-80c0-48-14-94-48-128S48 272 0 272v-80zM0 64c212 0 384 172 384 384h-80c0-171-133-304-304-304V64z"/></svg></div>
    </a>
    <a href="mailto:me@wesleyac.com" target="_blank" title="Email">
      <div style="width:18px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M422 407c-24 25-52 43-85 55s-69 18-105 18c-35 0-66-6-95-17s-53-26-73-46-36-43-47-71-17-58-17-90 6-62 18-89 29-51 50-71 46-35 74-47c28-11 58-17 90-17 28 0 55 4 81 12s49 20 69 36 36 36 48 60 18 53 18 85c0 24-3 46-10 64s-16 34-27 46-24 22-38 28-29 10-45 10-29-4-39-12-15-17-15-29h-3c-6 10-15 19-28 28s-28 13-46 13c-28 0-49-9-64-27s-23-42-23-71c0-17 3-34 9-50s14-31 24-44 23-23 38-31 31-12 49-12c15 0 27 4 38 10 10 6 18 15 21 24h1l5-24h54l-24 113c-1 6-2 12-3 19s-2 13-2 19c0 7 1 13 4 18s7 7 15 7c16 0 29-9 39-26s16-40 16-68c0-24-4-45-12-64s-20-34-34-47-32-23-52-29-41-9-65-9c-26 0-49 4-70 13s-39 22-54 38-27 34-35 56c-8 21-13 44-13 69 0 26 4 51 13 72s21 39 37 54 35 27 57 35 46 12 72 12c33 0 61-6 85-16s45-25 65-43zM231 188c-10 0-18 2-25 8s-14 13-19 22-8 18-11 28-4 20-4 30c0 5 0 10 1 16 1 5 3 10 6 15s7 8 12 11 11 5 19 5c11 0 20-3 28-8s14-13 19-21 9-16 11-26 3-19 3-27c0-6 0-13-1-19s-4-12-7-17-7-9-12-12-12-5-20-5z"/></svg></div>
    </a>
    <a href="https://github.com/WesleyAC" target="_blank" title="GitHub">
      <div style="width:18px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224 32c124 0 224 103 224 230 0 101-64 188-153 218h-4c-8 0-12-7-12-12 0-8 1-31 1-62 0-21-8-36-16-43 50-6 103-25 103-113 0-25-9-46-23-62 2-6 10-29-2-61h-5c-8 0-27 3-57 24-18-5-37-8-56-8s-38 3-56 8c-30-21-49-24-57-24h-5c-12 32-4 55-2 61-14 16-23 37-23 62 0 88 52 107 102 113-6 6-12 16-14 31-6 3-16 6-26 6-13 0-28-5-39-25 0 0-13-22-35-24-2 0-21 0-1 14 0 0 15 8 25 34 0 0 10 33 53 33 7 0 14 0 22-2v39c0 5-3 11-11 11h-4C64 450 0 364 0 262 0 135 100 32 224 32z"/></svg></div>
    </a>
  </div>
</nav>

    <article>
      <header class="article-header">
        <h1>Motivating X3DH</h1>
        <div class="article-list-date">
          Jan 13, 2024
        </div>
      </header>

      <div class="article-content">
        <p><a href="https://signal.org/">Signal</a> uses a protocol called &quot;<a href="https://signal.org/docs/specifications/x3dh/">Extended Triple Diffie-Hellman</a>&quot; (X3DH) for key agreement<sup id="fnref1"><a href="#fn1">1</a></sup>. This essentially takes standard <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman key exchange</a>, and enables it to be used where one party may be offline while they&#39;re receiving a message, while providing forward secrecy.</p>

<p>While the paper clearly explains how to implement X3DH, the <em>why</em> is slightly less clear. In this post, I&#39;ll briefly explain how X3DH works, then investigate what security property each of the steps involved is aimed at providing, and why particular choices were made around the signature algorithm.</p>

<h2>A quick summary of X3DH</h2>

<p>(This summary requires a understanding of Diffie-Hellman key exchange — if you are unfamiliar or need a refresher, take a look at this footnote<sup id="fnref2"><a href="#fn2">2</a></sup>)</p>

<p>In X3DH, the receiving party (who may be offline when they receive a message) uploads the following <a href="https://en.wikipedia.org/wiki/Curve25519">Curve2519</a> public keys to a server:</p>

<ul>
<li>A identity key (<code>IK_r</code>)</li>
<li>A &quot;signed prekey&quot; (<code>SPK</code>)</li>
<li>A signature for <code>SPK</code> with <code>IK_r</code></li>
<li>A number of &quot;one-time prekeys&quot; (<code>OPK1</code>, <code>OPK2</code>, …)</li>
</ul>

<p>When the sending party wants to send a message, they download from the server <code>IK</code>, <code>SPK</code>, the signature for <code>SPK</code>, and one of the one-time prekeys (which the server deletes and does not use for future runs).</p>

<p>The sender has two keys:</p>

<ul>
<li>A long-term identity key (<code>IK_s</code>)</li>
<li>A ephemeral key used only for a single X3DH handshake (<code>EK</code>)</li>
</ul>

<p>After validating the <code>SPK</code> signature is correct, the sender can generate a shared secret by invoking the Diffie-Hellman function four times:</p>

<ul>
<li><code>DH(IK_s, SPK)</code></li>
<li><code>DH(EK,   IK_r)</code></li>
<li><code>DH(EK,   SPK)</code></li>
<li><code>DH(EK,   OPKn)</code></li>
</ul>

<p>The outputs of these functions are concatenated and run through a key derivation function to generate a shared secret. If the server has run out of <code>OPK</code>s, only the first three functions are performed, to the slight detriment of the forward-secrecy properties. This image summarizes the Diffie-Hellman functions that are preformed:</p>

<p><img src="../img/motivating-x3dh/all.svg"></p>

<h2>Why, though?</h2>

<p>This is a lot of stuff, and it&#39;s understandable to ask what it&#39;s all doing. There are two basic properties that we want our key exchange to provide:</p>

<p>The first is &quot;forward secrecy&quot; — that is, if the private keys are compromised after the X3DH handshake has been completed, a attacker will not be able to decrypt the message. This is why we need the ephemeral key, and why we don&#39;t just do standard Diffie-Hellman with the identity keys and call it a day.</p>

<p>The second is &quot;mutual authentication&quot; — that is, both of the parties know the identity of the other party that they&#39;re talking to, and know that they are not being impersonated. This is why we want long-term identity keys — it&#39;s much simpler to prove ownership of a single long-term key than it is one of many ephemeral keys.</p>

<p>So, we want to use long-term keys for mutual authentication, and ephemeral keys for forward secrecy, and we can understand the one-time prekey as the ephemeral key for the receiving side. What&#39;s the signed prekey doing, then? It primarily serves as a backup, in case the server runs out of one-time prekeys. The signed prekey is replaced every time the client uploads new one-time prekeys, and thus is is more ephemeral than the identity key (which hangs around indefinitely), but not so ephemeral that we might run out.</p>

<p>So, that&#39;s the explanation for <em>why</em> we have each of these keys. Once we have that, it&#39;s actually pretty clear why we do the set of Diffie-Hellman operations we do. If we look at the case without a one-time prekey, it&#39;s very clear:</p>

<ul>
<li>We need to do a exchange between the ephemeral keys (<code>EK</code> and <code>SPK</code>), in order to get forward secrecy.</li>
<li>We need to involve <code>IK_s</code> and <code>IK_r</code>, to provide mutual authentication.</li>
<li>We don&#39;t want to use <code>DH(IK_s, IK_r)</code>, because doing so does not provide any forward secrecy, and not doing so provides better deniability (since anyone could forge a convincing looking transcript of a X3DH session without knowing either of the identity private keys, by generating all the ephemeral keys themselves)</li>
</ul>

<p>With those constraints, we end up with the only thing we can have:</p>

<p><img src="../img/motivating-x3dh/no_opk.svg"></p>

<p>However, the case where we do have a one-time prekey offers us more options. In particular, we could swap the roles of <code>SPK</code> and <code>OPK</code>, giving use either of these:</p>

<p><center>
<img src="../img/motivating-x3dh/all.svg" style="display: inline-block;">
<img src="../img/motivating-x3dh/spk_opk_swap.svg" style="display: inline-block;">
</center></p>

<p>Signal chooses to take the somewhat simpler approach of keeping the role of <code>SPK</code> the same regardless of whether we have a <code>OPK</code>, just adding in <code>DH(EK, OPK)</code> in the case where <code>OPK</code> is available. While this has slightly worse forward secrecy properties on its own (the attacker can crack more of the DH outputs if they capture the <code>SPK</code> private key), this doesn&#39;t really matter, because the DH outputs are fed through a KDF anyways, which necessitates cracking all the DH outputs to capture the key<sup id="fnref3"><a href="#fn3">3</a></sup>.</p>

<h2>On signatures</h2>

<p>One thing we haven&#39;t talked about is the reason that the signature of <code>SPK</code> is needed. Here&#39;s the attack that&#39;s intended to prevent:</p>

<ul>
<li>Alice tries to send a message to Bob.</li>
<li>The server replies with Bob&#39;s <code>IK</code>, but values of <code>SPK</code> and <code>OPK</code> that it generated for itself, and thus knows the private keys for.</li>
<li>Alice sends a message. The server doesn&#39;t relay this to Bob (since he wouldn&#39;t be able to decrypt it), but instead holds on to it.</li>
<li>Later, the attacker compromises Bob&#39;s <code>IK</code> private key. Now they can calculate the shared secret, and read the initial message.</li>
</ul>

<p>Signing the <code>SPK</code> is a sensible way to prevent this. However, there are a few questions to ask about the particular way in which it&#39;s implemented in X3DH. Firstly: is it safe? Reusing keys for multiple purposes is can lead to disastrous results, and it&#39;s important to rigorously prove that any such construction is safe. My understanding is that most cryptographers believed this construction to be safe, but it was only <a href="https://eprint.iacr.org/2021/509.pdf">relatively recently that a actual proof for these specific algorithms was provided</a> (and even then, I&#39;m not entirely sure that the construction in that paper applies to X3DH, although I&#39;d be quite surprised if it didn&#39;t).</p>

<p>The second question relates to how one even goes about using the same keypair for Diffie-Hellman and EdDSA signing. The <a href="https://github.com/netfoundry/libsodium-doc/tree/master/quickstart#how-can-i-sign-and-encrypt-using-the-same-key-pair">standard approach</a> (other than &quot;don&#39;t do that&quot;, which is generally recommended) is to take a EdDSA key (which is a point on a <a href="https://en.wikipedia.org/wiki/Twisted_Edwards_curve">Twisted Edwards curve</a>) and convert it into X25519 key (which is a point on a <a href="https://en.wikipedia.org/wiki/Montgomery_curve">Montgomery curve</a>). This is convenient, since a point on a Twisted Edwards curve maps to a single point on Montgomery curve, but notably, a point on a Montgomery curve maps to <strong>two</strong> points on a Twisted Edwards curve<sup id="fnref4"><a href="#fn4">4</a></sup>.</p>

<p>Signal chooses to solve this by <a href="https://signal.org/docs/specifications/xeddsa/">defining a scheme called XEdDSA</a>, which specifies which of the two possible points to use.</p>

<p>One has to ask, though, why go through the effort, when you could just start with a Twisted Edwards curve? My guess is that the signature step wasn&#39;t added until Signal was already being deployed, so using Montgomery curves for identity would be a backwards incompatible change. My understanding it that Matrix uses Twisted Edwards curves from the start in their implementation of X3DH, which I think is quite sensible, given that they had the luxury of designing their protocol with Signal&#39;s hindsight.</p>

<p>This still raises the question of why they chose to use the same key at all — it&#39;s easy to imagine a system where the identity key is exclusively used for signing, and a separate (signed) key-exchange key is used. Given recent proofs of the security of composing EdDSA and X25519, I don&#39;t think there&#39;s any advantage to doing so at this point, and Signal probably didn&#39;t go down this path for the same reason that they needed to invent XEdDSA in the first place — they already had a bunch of Montgomery keys deployed, and didn&#39;t want to switch them out for Twisted Edwards keys.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Well, they now use a <a href="https://signal.org/docs/specifications/pqxdh/">post-quantum secure version</a>, but it&#39;s a similar idea.&nbsp;<a href="#fnref1">&#8617;</a></p>
</li>

<li id="fn2">
<p>Diffie-Hellman gives us a function <code>DH(private, public)</code> that takes a private key and a public key, and generates a secret value from them. Notably, two parties can each run the function with their own private key and the other party&#39;s public key, and they will both get the same value.&nbsp;<a href="#fnref2">&#8617;</a></p>
</li>

<li id="fn3">
<p>Ideally don&#39;t be like <a href="https://github.com/trailofbits/publications/blob/master/reviews/SimpleXChat.pdf">SimpleX</a> and accidentally forget to apply the KDF.&nbsp;<a href="#fnref3">&#8617;</a></p>
</li>

<li id="fn4">
<p>This is what lead to <a href="https://monocypher.org/quality-assurance/disclosures">a fun vulnerability</a> in the Monocypher library, where giving a all-zero signature would be considered valid for 50% of messages due to a incorrect internal conversion between the two forms.&nbsp;<a href="#fnref4">&#8617;</a></p>
</li>

</ol>
</div>

      </div>

      <br>
      <!--
ooops, coronavirus happened, guess we're not doing this anymore :(
hopefully someday...
<p>If you're in NYC and want to meet up over lunch/coffee to chat about the future of technology, <a href="mailto:me@wesleyac.com">get in touch with me</a>.</p>
-->

      <br>
    </article>
  </main>
  <script async src="/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</body>
</html>
